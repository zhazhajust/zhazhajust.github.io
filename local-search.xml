<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>广义动量守恒推导</title>
    <link href="/2025/02/27/rel_mom/"/>
    <url>/2025/02/27/rel_mom/</url>
    
    <content type="html"><![CDATA[<p>下面给出一个较为详细的推导思路，说明为什么会得到方程<br />[ (<em>+ q,) = 0 </em>= <em>^0 ;-; q,, ]<br />以及 (</em>^0 = m ^0 <em>^0) 等结果。这里 (</em>)指的是粒子的横向(与主传播方向正交)动量，() 是电磁势(矢势)，(q)是粒子电荷，(m) 是粒子质量，() 是相对论因子。下面分步骤说明。</p><hr /><h2 id="广义动量的定义与运动方程">1. 广义动量的定义与运动方程</h2><p>在经典电动力学中，带电粒子在电磁场中运动的拉格朗日量可以写作<br />[ ;=; -,m c^2, ;+; q, ;-; q,, ]<br />其中 () 是矢势、() 是标势，() 是粒子速度，(c)是光速。相应的<strong>广义动量</strong>(canonical momentum)定义为<br />[ ;=; ;=; + q,, ]<br />其中<br />[ ;=; m, (). ]<br />因此<br />[ ;=; ;-; q,. ]</p><h3 id="电磁场中的牛顿方程">电磁场中的牛顿方程</h3><p>带电粒子在电磁场中的相对论运动方程(牛顿-洛伦兹方程)可以写作<br />[ ;=; q,( + ). ]<br />若用广义动量 ( = + q) 来表述，则有<br />[ ;=; q, + q, ;=; q( + ), ]<br />因为 ( = -,- <em>t ) 且 () 也可以用 ()表示。经过一系列推导后，若在某些方向(比如横向方向())上，系统的对称性或平移不变性保证了对该分量的广义动量守恒，那么就会得到<br />[ (</em>+ q,_) ;=; 0. ]</p><hr /><h2 id="为何-_-q-0">2. 为何 ((_+ q,) = 0)？</h2><p>在文中(方程(10b))，作者给出的理由是「由于在 (y) 和 (z)方向的平移不变性(translationalinvariance)」，导致横向广义动量不随时间变化，即<br />[ (_+ q,) = 0. ]<br />换言之，在横向方向(相对于主传播或流动方向)没有空间上的变化或外力的额外依赖，因而该分量的广义动量守恒。</p><p>如果令 (<em>^0) 表示 (t &lt; 0) 时刻(或“初始”)的横向动量，且当(t&lt;0) 时矢势 ( = 0)，那么守恒量就是<br />[ </em>^0 + q,|<em>{t&lt;0} ;=; </em>^0. ]<br />因为守恒，所以在 (t) 的任何时刻都满足<br />[ <em>(t) + q,(t) ;=; </em>^0. ]<br />从而得到<br />[ <em>(t) ;=; </em>^0 - q,(t). ]<br />这正是方程(11)的主要形式。</p><hr /><h2 id="初始横向动量-_0-的物理含义">3. 初始横向动量 (_^0)的物理含义</h2><!-- 作者接下来又写道   --><p>[ <em>^0 ;=; m,^0 ,</em>^0 ;=; -,,m,c,, ]<br />表明最初(比如等离子体还未受到后续场作用时，(t&lt;0))，带电粒子在横向(())方向有一个初始速度(<em>^0)，对应的相对论动量即<br />[ </em>^0 = ^0 m <em>^0. ]<br />这里 (^0 = 1/) 表示初始速度对应的相对论因子。文中举例给出了 (</em>^0 =-,,m,c,) 这样一个具体数值，说明粒子初始时在负 (y) 方向以一定速度(()相关)运动。</p><hr /><h2 id="总结推导脉络">4. 总结推导脉络</h2><ol type="1"><li><strong>广义动量守恒的关键</strong>：由于在横向方向上(这里指 (y,z)或者作者只关注某个正交方向)不存在对粒子的净推力，或者说系统在该方向上具备平移对称性，因此(_+q,) 守恒。<br /></li><li><strong>初始条件</strong>：(t&lt;0)时，(=0)，故初始时刻的广义动量就是粒子的机械动量 (_^0)。<br /></li><li><strong>随时间推演</strong>：由于守恒量不变，可写出<br />[ <em>(t) + q,(t) ;=; </em>^0 <em>(t) ;=; </em>^0 - q,(t). ]<br /></li><li><strong>相对论动量表达</strong>：(<em>^0 =m,^0,</em>^0)，并且在具体物理情景(例如等离子体流动)中可以给出速度或动量的方向和大小，如文中的(-,m,c,)。</li></ol><!-- 这就是文中方程(10b) 和(11)背后的主要推导逻辑。 --><p>要点在于：<br />- 电磁场中，<strong>机械动量</strong> ()并非一定守恒，但<strong>广义动量</strong> ( + q)可能由于对称性而守恒。<br />-一旦认定在某个方向上无净力(或场结构具备平移不变性)，就可断言那一方向的广义动量守恒，从而得到(<em>= </em>^0 - q) 这样的形式。<br />- 初始条件决定了 (_^0)的具体值，再结合守恒方程就能得到随时间演化的横向动量。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cloudflare tunnel 内网穿透</title>
    <link href="/2025/02/02/cloudflare/"/>
    <url>/2025/02/02/cloudflare/</url>
    
    <content type="html"><![CDATA[<ul><li>https://cloudflared.cn/get-started/create-local-tunnel/</li></ul><p>Cloudflare 实现内网穿透主要通过其 <strong>CloudflareTunnel</strong>（也叫 Argo Tunnel）功能来实现。它允许你在不暴露公共 IP的情况下，将本地服务器或应用暴露到互联网上，从而实现内网穿透。以下是Cloudflare Tunnel 的基本工作原理和步骤：</p><h3 id="工作原理">工作原理：</h3><ol type="1"><li><strong>Cloudflare Tunnel</strong> 创建了一个从本地服务器到Cloudflare的加密隧道。你的应用或服务运行在内网中，但它通过这个隧道连接到Cloudflare 的网络。</li><li><strong>Cloudflare 网络</strong>接收到来自用户请求的流量，然后转发到本地服务器。</li><li>用户与本地服务进行交互时，数据流经过加密隧道传输，从而避免了暴露内网IP 地址和端口。</li></ol><h3 id="实现步骤">实现步骤：</h3><ol type="1"><li><strong>注册 Cloudflare 账户并添加域名：</strong><ul><li>如果还没有 Cloudflare 账户，首先去 <ahref="https://www.cloudflare.com">Cloudflare 官网</a> 注册一个。</li><li>将你的域名添加到 Cloudflare，并修改 DNS设置（如果是现有域名）。</li></ul></li><li><strong>安装 Cloudflare Tunnel 客户端：</strong><ul><li>在你的本地服务器上安装 <code>cloudflared</code> 客户端。你可以通过<ahref="https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation">Cloudflare的官方文档</a> 了解详细的安装过程。大致步骤：<ul><li>在 Linux 上，你可以使用以下命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb<br><span class="hljs-built_in">sudo</span> dpkg -i cloudflared-linux-amd64.deb<br></code></pre></td></tr></table></figure>对于没有sudo权限的普通用户 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64<br></code></pre></td></tr></table></figure></li><li>也可以在 macOS、Windows 等其他平台上进行类似安装。</li></ul></li></ul></li><li><strong>认证 Cloudflare Tunnel：</strong><ul><li>在服务器上运行以下命令，进行认证： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cloudflared tunnel login<br></code></pre></td></tr></table></figure></li><li>该命令会打开一个浏览器窗口，要求你登录到 Cloudflare账户并授权。</li></ul></li><li><strong>创建 Tunnel：</strong><ul><li>创建一个新的 Tunnel： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cloudflared tunnel create &lt;tunnel-name&gt;<br></code></pre></td></tr></table></figure></li><li>这会生成一个隧道 ID 和证书文件。</li></ul></li><li><strong>配置 Tunnel 代理：</strong><ul><li>设置隧道代理，通常是在本地应用监听的端口上。例如，如果你的服务在<code>localhost:8080</code> 上运行，可以使用以下命令将流量通过隧道转发：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cloudflared tunnel --url http://localhost:8080<br></code></pre></td></tr></table></figure></li><li>或者也可以直接更改配置文件"~/.cloudflared/config.yml"<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tunnel:</span> <span class="hljs-string">6bc4c976-1c0c-45a4-bab0-93b7eed4e1d1</span> <span class="hljs-comment"># 你的 Tunnel ID</span><br><span class="hljs-attr">credentials-file:</span> <span class="hljs-string">/home/yujq2/.cloudflared/6bc4c976-1c0c-45a4-bab0-93b7eed4e1d1.json</span><br><br><span class="hljs-attr">ingress:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hostname:</span> <span class="hljs-string">rentereview.cn</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">http://localhost:8080</span>  <span class="hljs-comment"># 你的 Web 服务监听端口</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">service:</span> <span class="hljs-string">http_status:404</span><br></code></pre></td></tr></table></figure></li><li>然后运行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cloudflared tunnel run &lt;tunnel-name&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>配置 DNS 和路由：</strong><ul><li><p>在 Cloudflare 控制面板中，配置你的 DNS 设置，将域名指向<code>cloudflare-tunnel</code>。</p></li><li><p>在 Cloudflare 的 DNS 配置中，添加一条 CNAME 记录，将子域（例如<code>tunnel.yourdomain.com</code>）指向<code>tunnel.cloudflare.com</code>。</p></li><li><p>总结一下</p></li><li><p>在 Cloudflare 控制面板中，通过 DNS 设置，手动添加一个 CNAME记录，将子域（如 tunnel.retereview.cn）指向your-tunnel-id.cfargotunnel.com。</p></li><li><p>确保你的 Cloudflare Tunnel 在本地启动并运行。</p></li><li><p>等待 DNS 记录生效后，你应该就可以通过访问 tunnel.retereview.cn来访问你本地的服务了。</p></li><li><p>或者通过cloudflared程序进行路由 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cloudflared tunnel route dns jayzquaz retereview.cn<br></code></pre></td></tr></table></figure></p></li><li><p>这将把域名 retereview.cn 路由到名为 jayzquaz 的 Tunnel。</p></li></ul></li><li><strong>启动和验证：</strong><ul><li>运行 Cloudflare Tunnel 服务： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cloudflared tunnel run &lt;tunnel-name&gt;<br></code></pre></td></tr></table></figure></li><li>此时，你的本地服务就已经通过 Cloudflare Tunnel暴露到互联网上了。</li></ul></li><li><strong>启用 "Always Use HTTPS" 设置</strong><ul><li><p>Cloudflare 提供了一个非常简单的方法来自动将所有 HTTP 流量重定向到HTTPS：通过 "Always Use HTTPS"选项。这是最直接的方式，适用于大多数场景。</p></li><li><p>操作步骤：</p></li><li><p>登录到你的 Cloudflare 控制面板。</p></li><li><p>选择你要配置的域名。</p></li><li><p>进入 "SSL/TLS" 设置页面。</p></li><li><p>在页面顶部，点击 "Edge Certificates" 选项卡。</p></li><li><p>向下滚动，找到 "Always Use HTTPS" 设置。</p></li><li><p>开启这个选项，将所有的 HTTP 请求自动重定向到 HTTPS。</p></li></ul></li></ol><h3 id="优点">优点：</h3><ul><li><strong>安全性高</strong>：内网不需要暴露在公网，只通过加密隧道进行通信。</li><li><strong>无公网 IP</strong>：适用于没有固定公网 IP 的环境。</li><li><strong>简化配置</strong>：不需要复杂的端口映射或 NAT 配置。</li></ul><h3 id="注意">注意：</h3><ul><li>Cloudflare Tunnel 是一种基于 Cloudflare 的服务，因此需要有一个Cloudflare 账户，并且 DNS 需要指向 Cloudflare 才能使用。</li><li>可能会有流量限制或费用问题，特别是在高流量场景下。</li></ul><p>这种方式的好处是可以轻松实现内网穿透，并且利用 Cloudflare的全球加速和安全防护功能，使你的应用更加可靠和安全。如果有其他问题，或对某些配置有疑问，欢迎继续提问！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PIC模拟后处理</title>
    <link href="/2025/02/02/postpic/"/>
    <url>/2025/02/02/postpic/</url>
    
    <content type="html"><![CDATA[<h2 id="pic模拟后处理软件">PIC模拟后处理软件</h2><h4 id="postpic">postpic</h4><p>地址https://github.com/skuschel/postpic.git示例https://github.com/skuschel/postpic-examples.git</p><h4 id="visualpic">VisualPIC</h4><p>可视化GUI程序https://github.com/AngelFP/VisualPIC.git@dev</p><h4 id="picviewer">PICViewer</h4><p>PICViewer is a visualization GUI implemented on PyQt. dependency<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/yt-project/y</span>t.git<br></code></pre></td></tr></table></figure></p><p>Install <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">https:</span>//bitbucket<span class="hljs-meta">.org</span>/ecp_warpx/picviewer/<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Subtree仓库添加</title>
    <link href="/2025/02/02/subtree/"/>
    <url>/2025/02/02/subtree/</url>
    
    <content type="html"><![CDATA[<h2 id="step-1">Step 1</h2><p>初始化git仓库 git init 添加README.md文件 git add . git commit -m"Init"</p><h2 id="step-2">Step 2</h2><p>添加git subtree仓库 git remote add label <git-url> git fetch labelgit add subtree --prefix=<path> label/<branch></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算辐射物理</title>
    <link href="/2023/08/10/computation/"/>
    <url>/2023/08/10/computation/</url>
    
    <content type="html"><![CDATA[<h1id="computationalradiationphysics">ComputationalRadiationPhysics</h1><h2 id="opticspy">Opticspy</h2><p>Optics diffraction calculation.</p><p>https://github.com/opticspy/lightpipes.git</p><h2 id="clara2">Clara2</h2><p>Clara2 - a parallel classical radiation calculator based onLiénard-Wiechert potentials.</p><p>https://github.com/ComputationalRadiationPhysics/clara2</p><h2 id="picongpu">PIConGPU</h2><p>Performance-Portable Particle-in-Cell Simulations for the ExascaleEra.</p><p>https://github.com/ComputationalRadiationPhysics/picongpu.git</p><h2 id="meep">Meep</h2><p>free finite-difference time-domain (FDTD) software forelectromagnetic simulations</p><p>https://github.com/NanoComp/meep.git</p><p>and MIT Photonic-Bands: computation of photonic band structures inperiodic media</p><p>https://github.com/NanoComp/mpb.git</p><h2 id="gvf">GVF</h2><p>Gradient Vector Flow in Python based on the work of <ahref="http://www.iacl.ece.jhu.edu/static/gvf/">Chenyang Xu and JerryPrince</a>.</p><p>Gradient Vector Flow in 3D based on the work of <ahref="https://www.eriksmistad.no/3d-gradient-vector-flow-matlab-implementation/">ErikSmistad</a>.</p><p>https://github.com/Christophe-Foyer/GVF-Python.git</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习资源</title>
    <link href="/2023/08/10/datascience/"/>
    <url>/2023/08/10/datascience/</url>
    
    <content type="html"><![CDATA[<h2 id="数据分析入门">数据分析入门</h2><p>https://github.com/apachecn/pyda-2e-zh.git</p><h2 id="twitter算法">Twitter算法</h2><p>https://github.com/twitter/the-algorithm.git</p><h2 id="data-science笔记">Data Science笔记</h2><p>https://github.com/fengdu78/Data-Science-Notes</p><h2 id="machine-learning笔记">Machine Learning笔记</h2><p>吴恩达Machine learning笔记。</p><p>https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes.git</p><h2 id="day-machine-learning">100-Day-Machine-Learning</h2><p>100-Days-Of-ML-Code中文版</p><p>https://github.com/MLEveryday/100-Days-Of-ML-Code.git</p><h2 id="deep-learning-book">Deep Learning Book</h2><p>Deep Learning Book Chinese online：https://exacity.github.io/deeplearningbook-chinese/Chapter1_introduction/</p><p>Source Code：https://github.com/exacity/deeplearningbook-chinese.git</p><h2 id="huawei-拍月亮">Huawei 拍月亮</h2><p>https://github.com/zhazhajust/Learning-to-See-in-the-Dark.git</p><h2 id="gpt2.0">GPT2.0</h2><p>基于开源GPT2.0的初代创作型人工智能 | 可扩展、可进化</p><p>https://github.com/EssayKillerBrain/WriteGPT.git</p><h2 id="full-stack">Full Stack</h2><p>🚀 fullstack tutorial2022，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试。</p><p>https://github.com/frank-lam/fullstack-tutorial.git</p><h2 id="java">Java</h2><p>21天学会JAVA</p><p>https://github.com/DuGuQiuBai/Java.git</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>远程连接与唤醒</title>
    <link href="/2023/08/10/remote/"/>
    <url>/2023/08/10/remote/</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>首先准备好公网ipv4 oripv6，使用ddns-go绑定动态ip地址到dns服务器（静态ip不需要），此时可。随后运行WolGoWeb服务，即可使用url进行远程唤醒。</p><h2 id="dynv6">dynv6</h2><p>使用 https://dynv6.com 进行动态域名解析，绑定ipv6于自定义域名https://xxx.dynv6.net 。</p><h2 id="ddns-go">ddns-go</h2><p>简单好用的DDNS。自动更新域名解析到公网IP(支持阿里云、腾讯云、Dnspod、Cloudflare、Callback、华为云、百度云、Porkbun、GoDaddy、GoogleDomain)</p><p>https://github.com/jeessy2/ddns-go.git</p><p>此时，ipv6已解析于ddns服务器，通过自定义url可以通过远程连接软件如rdp、moonlight、parsec等直接访问。</p><h2 id="wolgoweb">WolGoWeb</h2><p>基于Golang的Web服务器，使用url链接即可发起wake on lan局域网唤醒。</p><p>https://github.com/zhazhajust/WolGoWeb.git</p><p>然后测试url唤醒，在浏览器输入http://xxx:9090/wol?mac=00-00-00-00-00-00 （网卡MAC地址）。</p><h2 id="wake-on-lan-gui-程序optional">Wake On Lan GUI程序（Optional）</h2><p>https://github.com/basildane/WakeOnLAN.git</p><h3 id="参考文献">参考文献</h3><p>https://www.jianshu.com/p/6622c33f4cd3</p><p>https://zhouym.tech/2022/Wake-On-Lan/</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>远程连接与唤醒</title>
    <link href="/2023/08/10/vtk/"/>
    <url>/2023/08/10/vtk/</url>
    
    <content type="html"><![CDATA[<h1 id="vtk-and-paraview">VTK and Paraview</h1><p>vtk examples:https://examples.vtk.org/site/Python/IO/WriteXMLLinearCells/</p><p>source: https://github.com/Kitware/vtk-examples</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2022物院新生定向越野圆满结束</title>
    <link href="/2022/10/03/tuisong/"/>
    <url>/2022/10/03/tuisong/</url>
    
    <content type="html"><![CDATA[<h1 id="物院新生定向越野圆满结束">2022物院新生定向越野圆满结束</h1><p>  年年岁岁花相似，岁岁年年人不同。又是一年开学季，又是定向越野时。今年的定向越野活动有50多位物院新生报名参赛，探索北大的每一个角落，邂逅校园中的美丽风景与悠久历史。早晨8:30，随着第一批队伍的出发，定向越野赛正式开始。一个个少年和少女充满斗志，神采飞扬，按照地图的指引，向着各个任务点奔去。</p><h2 id="地图如下">地图如下</h2><figure><img src="/tuisong/image1.jpg" alt="图片1" /><figcaption aria-hidden="true">图片1</figcaption></figure><p>  可以看到定向越野过程中共设置八个任务点，各有一个趣味小游戏  <strong><em>快来看看大家的精彩瞬间叭～</em></strong></p><h2 id="主线1拓扑手环">主线1、拓扑手环</h2><h3 id="游戏规则">游戏规则</h3><p>  游戏开始时，四个人站在一起闭上眼，伸出双手，由场务任意组合8只手，听到口令“睁眼”后，4位同学睁眼并通过各种方式将手环解开，但不能松手，直到四个人围成一个环，计时评分。  <em>同学们用曼妙的舞姿分离了交缠的肢体，解开了拓扑学的难题。</em></p><figure><img src="/tuisong/image2.jpg" alt="图片2" /><figcaption aria-hidden="true">图片2</figcaption></figure><h2 id="主线2同心棍">主线2、同心棍</h2><h3 id="游戏规则-1">游戏规则</h3><p>  四人分为两组，相向站立，每人伸出一只手指，大家共同将一根水平的长棍子从某一高度放到地上，计时评分。  <em>未名湖的湖中仙女将强大的物理学圣剑交到了勇者手中，他们能顺利将圣剑接引到地面吗?</em></p><figure><img src="/tuisong/image3.jpg" alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><h2 id="主线3砸沙包">主线3、砸沙包</h2><h3 id="游戏规则-2">游戏规则</h3><p>  每人两个沙包，在5m之外投掷击倒纸箱金字塔，以击倒纸箱个数计分。  <em>最终没有小组能将纸箱全部击倒，大家对抛物线的计算还有待提高啊。</em></p><figure><img src="/tuisong/image4.jpg" alt="4" /><figcaption aria-hidden="true">4</figcaption></figure><h2 id="主线4吹乒乓">主线4、吹乒乓</h2><h3 id="游戏规则-3">游戏规则</h3><p>  提供两个装满水的纸杯，三个人参与，其中两个人端稳水杯，一个人将乒乓球从一个水杯吹入另一个水杯，掉落即停，中途不允许向杯中加水。  <em>小球在空中飞跃短暂而美妙的弧线，同学们的心也随之一起一落；地面上的水渍逐渐扩大，杯中的水面一点点下降，焦急的情绪又在不经意间升起</em></p><figure><img src="/tuisong/image5.jpg" alt="5" /><figcaption aria-hidden="true">5</figcaption></figure><h2 id="主线5四人两足">主线5、四人两足</h2><h3 id="游戏规则-4">游戏规则</h3><p>  4人一组，在地上一个方形区域内根据指令相互配合使规定部位着地完成动作，每个动作必须定格三秒才算过关。  <em>同学们的身体缠缠绵绵，交错纵横，饱受肌肤相亲之苦，到底是谁想出来的这么离谱的游戏啊（对啊是谁啊，笑）。</em></p><figure><img src="/tuisong/image6.jpg" alt="6" /><figcaption aria-hidden="true">6</figcaption></figure><h2 id="主线6激光反射">主线6、激光反射</h2><h3 id="游戏规则-5">游戏规则</h3><p>  一人背上贴带区域标记的A4纸，手持激光笔，其余三人各持一面小镜子，将激光成功沿要求的光路反射至A4纸上特定区域上并保持5秒则成功。  <em>大家都忘了基本光路知识了吗？不过话说回来，直接拿激光笔往身后一照这个bug，啊这是可以做的吗？</em></p><figure><img src="/tuisong/image7.jpg" alt="7" /><figcaption aria-hidden="true">7</figcaption></figure><h2 id="主线7数字游戏">主线7、数字游戏</h2><h3 id="游戏规则-6">游戏规则</h3><p>  参与者站成一排，每个人会按照一定规律对应一些数字，当喊出某个正数时，离该数字最近的玩家需要喊“到”。  <em>反应快的同学也许发现了规律，但当第一个数字报出来的那一刻所有人几乎无一例外的大脑过载，啊呀口算eπ也不是不可以的嘛。</em></p><figure><img src="/tuisong/image8.jpg" alt="8" /><figcaption aria-hidden="true">8</figcaption></figure><h2 id="主线8空气动力学飞机">主线8、空气动力学飞机</h2><h3 id="游戏规则-7">游戏规则</h3><p>  每组四个人分别叠好一架纸飞机并放飞，每人只能得到一张纸。  <em>静园的草坪之上，飞扬的纸飞机承载着我们的梦想，自由的翱翔于蓝天之上（<del>然后重重摔倒地上</del>），每个人的童年都少不了纸飞机的陪伴，而它也永远寄托着我们的希望。</em></p><figure><img src="/tuisong/image9.jpg" alt="9" /><figcaption aria-hidden="true">9</figcaption></figure><p>  在完成主线任务后，同学们可以获得一些神秘字母和照片。照片可以解锁燕园之中的隐藏点，进一步帮助同学们探索校园，而字母可以拼成——</p>***<center>WELCOM TO PKUPHYS!</center><hr /><p>  哈哈，希望各位新生在本次活动中能更好的熟悉校园，熟悉北大，也能认识更多的朋友，留下美好的回忆。最后，欢迎来到北大物院！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Frequency moved undulator</title>
    <link href="/2022/09/15/undulator/"/>
    <url>/2022/09/15/undulator/</url>
    
    <content type="html"><![CDATA[<h2 id="smilei-or-epoch">Smilei or EPOCH</h2><p>Mark the oscillate electrons, and save the field produced by them.Then sparated them from the total electric field and save to a newfile.</p><h2 id="光波荡器推导">光波荡器推导</h2><p>假设平面波激光方向为<span class="math inline">\(\hat k =\textbf{k}/k_L\)</span>，则 <span class="math inline">\(B = (\hat k\times E)/c\)</span>,电子在激光场中运动方程写为：</p><p><span class="math inline">\(\frac{d}{dt}(\gamma mc \beta) = -e(E + v\times B)\)</span></p><p><span class="math inline">\(\frac{d}{dt}(\gamma mc \beta) = -e[E +\beta \times (\hat k \times E)] = -e[E + (\beta \cdot E)\hat k - (\beta\cdot \hat k)E]\)</span></p><p>我们假设激光沿着x方向偏振，<span class="math inline">\(E = E_0sin(\omega_Lt − k \cdot x)\hatx\)</span>，沿着z方向传播，与z轴呈夹角<spanclass="math inline">\(\varphi\)</span>，波矢<spanclass="math inline">\(k = k_L(0, -sin \varphi, +cos\varphi)\)</span>，并且 <span class="math inline">\(\omega_L =ck_L\)</span>。运动方程写为：</p><p><span class="math inline">\(\frac{d}{dt}(\gamma mc \beta) =-eE_0sin(ck_Lt - \textbf{k} \cdot x)[1 - (\hat k \cdot \beta)] =\frac{eE_0}{ck_L}\frac{d}{dt}cos(ck_Lt - \textbf{k} \cdotx)\)</span></p><p>方程表明水平方向动量守恒，通过积分可以很容易得出，</p><p><span class="math inline">\(\beta_x = \frac{eE_0}{\gammamc^2k_L}cos(ck_Lt - \textbf{k}\cdot x)\)</span></p><p>波荡器参数为<span class="math inline">\(K =\frac{eE_0}{mc^2k_L}\)</span>，对于Undulator， <spanclass="math inline">\(K&lt;&lt;1\)</span>，<span class="math inline">\(t\approx c/\beta_z\)</span>，横向振动速度为<spanclass="math inline">\(cos(k_L(1/\overline{\beta}_z - cos\varphi)z +k_Lysin\varphi)\)</span>，则波荡器周期为：</p><p><span class="math inline">\(\lambda_u \rightarrow\frac{\overline{\beta}_z\lambda_L}{1 -\overline{\beta}_zcos\varphi}\)</span></p><p>将波荡器周期和参数K带入波荡器辐射公式,</p><p><span class="math inline">\(\frac{\lambda_1(\phi)}{c} =\frac{\lambda_u}{c}[\frac{1 + K^2/(4\gamma^2)}{\beta} - (1 -\frac{\phi^2}{2})] \approx \frac{\lambda_u}{c}\frac{1 + K^2/2 +\gamma^2\phi^2}{2\gamma^2}\)</span></p><p>同步辐射共振波长为</p><p><span class="math inline">\(\lambda = \frac{1 +K^2/2}{2\gamma^2}\frac{\lambda_L}{1 -\overline{\beta}_zcos\varphi}\)</span></p><p>当满足<span class="math inline">\(\varphi \rightarrow 0, K &lt;&lt;1(undulator的假设)\)</span>时</p><p><span class="math inline">\(\lambda \rightarrow\lambda_L\)</span></p><h2 id="时间收缩效应">时间收缩效应</h2><p>假设<spanclass="math inline">\(t^{&#39;}\)</span>为粒子静止坐标系，则 <spanclass="math inline">\(1 - \beta(t^{&#39;})cos\phi(t^{&#39;})\)</span>为时间收缩因子，对于相对论电子，</p><p><span class="math inline">\(\beta = \sqrt{1 - \frac{1}{\gamma^2}}\approx 1 - \frac{1}{1\gamma^2}\)</span></p><p>对于gamma &gt;&gt; 1，<span class="math inline">\(\phi &lt;&lt;1\)</span></p><p><span class="math inline">\(1 - \beta cos\phi \approx\frac{1}{2}(\frac{1}{\gamma^2} + \phi^2)\)</span></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>太赫兹鬼成像</title>
    <link href="/2022/08/17/numerical/"/>
    <url>/2022/08/17/numerical/</url>
    
    <content type="html"><![CDATA[<h1 id="偏微分方程求解">偏微分方程求解</h1><p>对于波动方程等偏微分方程，难以直接求解析解，一般采用数值方法求解。目前电磁学主要通过有限元法（FEM）（通过Galerkin法基函数分解）、有限时域差分法（FDTD）、矩量法（MoM）等进行数值模拟。对于更一般的偏微分方程求解方法，这里介绍Methodof Lines方法求解。</p><h2 id="method-of-lines">Method of Lines</h2><p>Method of Lines是求解偏微分方程的一种通用计算方法。Method ofLines方法通过空间离散，将偏微分方程转化为常微分方程组ODEs，后续通过Eular法，隐式欧拉法（牛顿迭代、不动点法）等求解。</p><h2 id="基本案例">基本案例</h2><p>例：求解扩散方程</p><p><span class="math inline">\(\partial u/\partial t = D\partial^2u/\partial^2 x\)</span></p><p>将<spanclass="math inline">\(D\partial_x^2\)</span>离散化为矩阵A，将<spanclass="math inline">\(\frac{d}{dt}U\)</span>写为<spanclass="math inline">\(\dot U\)</span>，使用矩阵形式表示为<spanclass="math inline">\(\dot U = AU\)</span>。</p><p>例如<span class="math inline">\(\frac{du_i}{dt} =-v\frac{du}{dx}\)</span> 方程转化为<spanclass="math inline">\(\frac{du_i}{dt} = -v\frac{(u_i - u_{i-1})}{\deltax}, 1 \leq i \leq M\)</span>，再转化为矩阵形式。</p><h2 id="forward-eular">forward eular</h2><p>讲矩阵乘积写为函数形式 <span class="math inline">\(\dot U =F(U)\)</span> 则可使用前向欧拉法进行求解 <spanclass="math inline">\(U_{k+1} = U_k + \delta tF(U_k)\)</span></p><h2 id="rk方法">RK方法</h2><p>龙格库塔方法显式求解Method ofLines得到的ODEs，可以得到更高精度的解。</p><p>积分中值定理可以得出 <span class="math inline">\(U(t + \delta t) =U(t) + \delta tF(U(t + \frac{1}{2}\delta t)) + O(\deltat^3)\)</span></p><p>龙格库塔法通过预测<span class="math inline">\(U(t + \frac{1}{2}\deltat)\)</span>来使用前向欧拉法</p><p><span class="math inline">\(\widetilde U_{k+\frac{1}{2}} = U_k +\frac{\delta t}{2}F(U_k)\)</span></p><p><span class="math inline">\(U_{k+1} = U_k + \delta tF(\widetildeU_{k+\frac{1}{2}})\)</span></p><p>这是一种两阶段方法。第一阶段预测中点值,第二阶段，即校正阶段，使用预测的中点值进行时间步进。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛顿迭代法隐式欧拉法求解微分方程</title>
    <link href="/2022/08/16/NewtonMethod/"/>
    <url>/2022/08/16/NewtonMethod/</url>
    
    <content type="html"><![CDATA[<h1 id="牛顿迭代法求解ode">牛顿迭代法求解ODE</h1><p>首先根据 dy/dx = f(x, y) 构建 F(x, y) = 0，然后求解F(x,y)对y的导数，然后迭代求解零点误差 abs(F(x, y) - F(x, next_y))最小处的y，将next_y作为y带入下一个递归，</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> sympy<br><br>x = np.zeros(<span class="hljs-number">20</span>)<br>y = np.zeros(<span class="hljs-number">20</span>)<br>y_E = np.zeros(<span class="hljs-number">20</span>)<br>z = np.zeros(<span class="hljs-number">20</span>)<br>x[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>y[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>y_E[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>z[<span class="hljs-number">0</span>] = (<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*x[<span class="hljs-number">0</span>])**<span class="hljs-number">0.5</span><br>h = <span class="hljs-number">0.05</span><br><br># dy/dx 导数<br>def f(x, y):<br>    return y<span class="hljs-number">-2</span>*x/y<br><br>############################<br>##### 牛顿迭代法构建方程 #####<br>############################<br><br># dy/dx = f(x, y)<br># y - yn = (x - xn) * f(x, y)<br># h * f(x, y) - (y - yn) = <span class="hljs-number">0</span><br>def F(x, y, yn):<br>    return h * f(x, y) - (y - yn)<br><br># 求解dF(x, y, yn)/dy<br># d(<span class="hljs-number">0.05</span> * (y - <span class="hljs-number">2</span>*x/y) - y + yn) / dy<br># <span class="hljs-number">0.05</span> * (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>*x/y**<span class="hljs-number">2</span>) - <span class="hljs-number">1</span><br># <span class="hljs-number">0.1</span> * x/y**<span class="hljs-number">2</span> - <span class="hljs-number">0.95</span><br>def dF(x, y):<br>    return <span class="hljs-number">0.1</span>*x/y**<span class="hljs-number">2</span> - <span class="hljs-number">0.95</span><br><br>############################<br>############################<br>############################<br><br>def newtonMethod(assum, d1, d3):<br>    y = assum<br>    Next_y = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> F(d1, y, d3) == <span class="hljs-number">0.0</span>:<br>        return  y<br>    else:<br>        Next_y = y - F(d1, y, d3) / dF(d1, y)<br><br>    # 零点距离<br>    <span class="hljs-keyword">if</span> abs(F(d1, y, d3) - F(d1, Next_y, d3)) &lt; <span class="hljs-number">1e-5</span>:<br>        return Next_y<br>        <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-string">&#x27;设置迭代跳出条件, 同时输出满足f(x) = 0的x值&#x27;</span><span class="hljs-string">&#x27;&#x27;</span><br>    else:<br>        return newtonMethod(Next_y, d1, d3)<br><br><br>for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>):<br>    x[i] = x[i<span class="hljs-number">-1</span>]+h<br>    y[i] = newtonMethod(<span class="hljs-number">4</span>, x[i], y[i<span class="hljs-number">-1</span>])<br>    y_E[i] = y_E[i<span class="hljs-number">-1</span>] + h*f(x[i<span class="hljs-number">-1</span>], y_E[i<span class="hljs-number">-1</span>])<br>    z[i] = (<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*x[i])**<span class="hljs-number">0.5</span><br><br>plt.plot(x, y, label=<span class="hljs-string">&#x27;Implicit Euler&#x27;</span>, color=<span class="hljs-string">&#x27;green&#x27;</span>)<br>plt.plot(x, y_E, label=<span class="hljs-string">&#x27;Euler&#x27;</span>, color=<span class="hljs-string">&#x27;orange&#x27;</span>)<br>plt.plot(x, z, label=<span class="hljs-string">&#x27;true&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Marching Cube算法提取网格</title>
    <link href="/2022/08/15/pymesh/"/>
    <url>/2022/08/15/pymesh/</url>
    
    <content type="html"><![CDATA[<h1 id="pymesh3d">PyMesh3D</h1><h2 id="basic-installation">Basic Installation</h2><p>This project for mesh render in data science.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install --upgrade pip<br>pip install pymesh3d<br></code></pre></td></tr></table></figure><p>If you need mayavi backend.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install mayavi<br>pip install pyqt<br></code></pre></td></tr></table></figure><h2 id="quick-start">Quick Start</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymesh<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>Look at the directory example for full example.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##########################################</span><br><span class="hljs-comment">############ Rotate Mesh Data ############</span><br><span class="hljs-comment">##########################################</span><br><br>wkdir = <span class="hljs-string">&quot;../../Render&quot;</span><br><br>ey = np.load(wkdir + <span class="hljs-string">&quot;/Ez.npy&quot;</span>)[::<span class="hljs-number">2</span>, ::<span class="hljs-number">50</span>]<br><br>m, n = ey.shape[<span class="hljs-number">0</span>], ey.shape[<span class="hljs-number">1</span>]<br>res = np.zeros([m, n, n])<br>pymesh.rotate(ey, res, ifhalf = <span class="hljs-literal">False</span>)<br><br>fig = plt.figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))<br>plt.contourf(res[:, <span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>), :].T)<br>cbar = plt.colorbar()<br></code></pre></td></tr></table></figure><figure><imgsrc="https://github.com/zhazhajust/pymesh/blob/main/example/example_files/example_1_0.png?raw=true"alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##########################################</span><br><span class="hljs-comment">############# Save Mesh Data #############</span><br><span class="hljs-comment">##########################################</span><br><br>mesh = pymesh.get_iso_surf(res, contours_number = <span class="hljs-number">4</span>, cmap = <span class="hljs-string">&quot;jet&quot;</span>)<br>color = pymesh.interp_color(mesh.iso_vals, cmap = <span class="hljs-string">&quot;jet&quot;</span>)<br>mesh.export(wkdir + <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;obj&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##########################################</span><br><span class="hljs-comment">############# Load Mesh Data #############</span><br><span class="hljs-comment">##########################################</span><br><br>mesh = pymesh.Mesh.load(wkdir + <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;obj&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##########################################</span><br><span class="hljs-comment">############# Plot Mesh Data #############</span><br><span class="hljs-comment">##########################################</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mayavi <span class="hljs-keyword">import</span> mlab<br><br>mlab_mesh = pymesh.iso_surface(mesh, colormap = <span class="hljs-string">&quot;RdBu&quot;</span>)<br>mlab.colorbar()<br>mlab.show()<br></code></pre></td></tr></table></figure><figure><imgsrc="https://github.com/zhazhajust/pymesh/blob/main/example/example_files/example_3_0.png?raw=true"alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">################ plt example #################</span><br><br>surf = mesh.plt_trisurf(cmap = <span class="hljs-string">&quot;jet&quot;</span>)<br>plt.colorbar(surf, orientation = <span class="hljs-string">&#x27;horizontal&#x27;</span>)<br>plt.tight_layout()<br></code></pre></td></tr></table></figure><figure><imgsrc="https://github.com/zhazhajust/pymesh/blob/main/example/example_files/example_2_0.png?raw=true"alt="png" /><figcaption aria-hidden="true">png</figcaption></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>太赫兹鬼成像</title>
    <link href="/2022/08/11/ghostimg/"/>
    <url>/2022/08/11/ghostimg/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">1 简介</h1><h2 id="量子鬼成像">1.1 量子鬼成像</h2><h2 id="经典鬼成像">1.2 经典鬼成像</h2><h2 id="计算成像">1.3 计算成像</h2><h1 id="原理">2 原理</h1><h2 id="section">2.1</h2><h2 id="section-1">2.2</h2><h1 id="鬼成像方案">3 鬼成像方案</h1><h2 id="si编码">3.1 SI编码</h2><h2 id="vo2编码">3.2 VO2编码</h2><h2 id="泵浦光编码">3.3 泵浦光编码</h2><h1 id="发展方向">4 发展方向</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态开点线段树</title>
    <link href="/2022/07/09/segmentTree/"/>
    <url>/2022/07/09/segmentTree/</url>
    
    <content type="html"><![CDATA[<h2 id="动态线段树模板">动态线段树模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @Description: 线段树（动态开点）</span><br><span class="hljs-comment"> * @Author: LFool</span><br><span class="hljs-comment"> * @Date 2022/6/7 09:15</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTreeDynamic</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node left, right;<br>        <span class="hljs-type">int</span> val, add;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> N = (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">private</span> Node root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;<br>            node.val += (end - start + <span class="hljs-number">1</span>) * val;<br>            node.add += val;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (start + end) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">pushDown</span>(node, mid - start + <span class="hljs-number">1</span>, end - mid);<br>        <span class="hljs-keyword">if</span> (l &lt;= mid) <span class="hljs-built_in">update</span>(node.left, start, mid, l, r, val);<br>        <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">update</span>(node.right, mid + <span class="hljs-number">1</span>, end, l, r, val);<br>        <span class="hljs-built_in">pushUp</span>(node);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) <span class="hljs-keyword">return</span> node.val;<br>        <span class="hljs-type">int</span> mid = (start + end) &gt;&gt; <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pushDown</span>(node, mid - start + <span class="hljs-number">1</span>, end - mid);<br>        <span class="hljs-keyword">if</span> (l &lt;= mid) ans += <span class="hljs-built_in">query</span>(node.left, start, mid, l, r);<br>        <span class="hljs-keyword">if</span> (r &gt; mid) ans += <span class="hljs-built_in">query</span>(node.right, mid + <span class="hljs-number">1</span>, end, l, r);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        node.val = node.left.val + node.right.val;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> leftNum, <span class="hljs-type">int</span> rightNum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node.left == null) node.left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        <span class="hljs-keyword">if</span> (node.right == null) node.right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        <span class="hljs-keyword">if</span> (node.add == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;<br>        node.left.val += node.add * leftNum;<br>        node.right.val += node.add * rightNum;<br>        <span class="hljs-comment">// 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖</span><br>        node.left.add += node.add;<br>        node.right.add += node.add;<br>        node.add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于表示为「区间和」且对区间进行「加减」的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量(注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！(这种情况和模版一致！！)如题目 最近的请求次数对于表示为「区间和」且对区间进行「覆盖」的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量(注意是叶子节点的数量)』；我们在下推懒惰标记的时候『不需要累加』！！(因为是覆盖操作！！)如题目 区域和检索 - 数组可修改对于表示为「区间最值」且对区间进行「加减」的更新操作的情况，我们在更新节点值的时候『不需要✖️左右孩子区间叶子节点的数量(注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！如题目 我的日程安排表 I、我的日程安排表 III</p><h2 id="我的日程安排表-i">我的日程安排表 I</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendar</span>;<br>    <span class="hljs-comment">// 左右孩子节点</span><br>    Node *left, *right;<br>    <span class="hljs-comment">// 当前节点值，以及懒惰标记的值</span><br>    <span class="hljs-type">int</span> val, add;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendar</span> &#123;<br>    <span class="hljs-keyword">public</span>:    <br>        <span class="hljs-built_in">MyCalendar</span>():<span class="hljs-built_in">N</span>(<span class="hljs-number">1e9</span>), <span class="hljs-built_in">root</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>())&#123;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>            <span class="hljs-comment">// 先查询该区间是否为 0</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(root, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 更新该区间</span><br>            <span class="hljs-built_in">update</span>(root, <span class="hljs-number">0</span>, N, start, end - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Node* node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;<br>                node -&gt; val += val;<br>                node -&gt; add += val;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-built_in">pushDown</span>(node);<br>            <span class="hljs-type">int</span> mid = (start + end) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) <span class="hljs-built_in">update</span>(node -&gt; left, start, mid, l, r, val);<br>            <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">update</span>(node -&gt; right, mid + <span class="hljs-number">1</span>, end, l, r, val);<br>            <span class="hljs-built_in">pushUp</span>(node);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node* node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) <span class="hljs-keyword">return</span> node -&gt; val;<br>            <span class="hljs-built_in">pushDown</span>(node);<br>            <span class="hljs-type">int</span> mid = (start + end) &gt;&gt; <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (l &lt;= mid) ans = <span class="hljs-built_in">query</span>(node -&gt; left, start, mid, l, r);<br>            <span class="hljs-keyword">if</span> (r &gt; mid) ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(node -&gt; right, mid + <span class="hljs-number">1</span>, end, l, r));<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    <span class="hljs-comment">// *************** 下面是模版 ***************</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> N;<br>        Node* root;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>            <span class="hljs-comment">// 每个节点存的是当前区间的最大值</span><br>            node -&gt; val = <span class="hljs-built_in">max</span>(node -&gt; left -&gt; val, node -&gt; right -&gt; val);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (node -&gt; left == <span class="hljs-literal">nullptr</span>) node -&gt; left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            <span class="hljs-keyword">if</span> (node -&gt; right == <span class="hljs-literal">nullptr</span>) node -&gt; right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            <span class="hljs-keyword">if</span> (node -&gt; add == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;<br>            node -&gt; left -&gt; val += node -&gt; add;<br>            node -&gt; right -&gt; val += node -&gt; add;<br>            node -&gt; left -&gt; add += node -&gt; add;<br>            node -&gt; right -&gt;add += node -&gt; add;<br>            node -&gt; add = <span class="hljs-number">0</span>;<br>        &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCalendar object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCalendar* obj = new MyCalendar();</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;book(start,end);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反滤波</title>
    <link href="/2022/07/05/antiFilter/"/>
    <url>/2022/07/05/antiFilter/</url>
    
    <content type="html"><![CDATA[<h2 id="使用傅里叶变换去卷积和逆滤波">使用傅里叶变换去卷积和逆滤波</h2><p>如果已经有了一张具有模糊核的模糊图像，我们需要将其恢复到原始图像。原理上，我们只需要对原有的滤波卷积核每一个值进行倒数的操作即可实现逆滤波器的效果。在此我们仍然是在频域上进行卷积，代码如下。</p><p>需要注意的是，卷积核取到数的过程中需要在原来的数值上加一个微小数值epsilon，以避免分母为零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>im = EyEnd <span class="hljs-comment">#255*rgb2gray(imread(&#x27;./images/snow.jpg&#x27;))</span><br>gauss_kernel = np.outer(signal.gaussian(im.shape[<span class="hljs-number">0</span>], <span class="hljs-number">3</span>), signal.gaussian(im.shape[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>))<br> <br>freq = fp.fft2(im)<br>freq_kernel = fp.fft2(fp.ifftshift(gauss_kernel))<br>conv = freq*freq_kernel<br>im_blur = fp.ifft2(conv).real<br>im_blur = <span class="hljs-number">255</span>*im_blur/np.<span class="hljs-built_in">max</span>(im_blur)<br> <br>epsilon = <span class="hljs-number">10</span>**-<span class="hljs-number">6</span><br>freq = fp.fft2(im_blur)<br>freq_kernel = <span class="hljs-number">1</span>/(epsilon+freq_kernel) <span class="hljs-comment"># avoid freq_kernel is zero</span><br>im_rst = fp.ifft2(conv).real<br>im_rst = <span class="hljs-number">255</span>*im_rst/np.<span class="hljs-built_in">max</span>(im_rst)<br> <br>pylab.figure(figsize = (<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>pylab.subplot(<span class="hljs-number">221</span>), pylab.imshow(im), pylab.title(<span class="hljs-string">&#x27;Original Image&#x27;</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>pylab.subplot(<span class="hljs-number">222</span>), pylab.imshow(im_blur), pylab.title(<span class="hljs-string">&#x27;Blurred Image Image&#x27;</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>pylab.subplot(<span class="hljs-number">223</span>), pylab.imshow(im_rst), pylab.title(<span class="hljs-string">&#x27;Restored Image with inverse filter&#x27;</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>pylab.subplot(<span class="hljs-number">224</span>), pylab.imshow(im_rst - im), pylab.title(<span class="hljs-string">&#x27;Diff Image&#x27;</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="利用维纳滤波器去卷积">利用维纳滤波器去卷积</h2><p>前面的去卷积方法需要已知模糊核，在这里使用维纳滤波器，在不知道模糊核的情况下，从损坏的信号中去除噪声，达到复原图像的目的。首先构造一个已经损坏了的图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>im = rgb2gray(imread(<span class="hljs-string">&#x27;./images/cat.jpg&#x27;</span>))<br> <br>n = <span class="hljs-number">7</span><br>psf = np.ones((n, n))/n**<span class="hljs-number">2</span><br>im1 = signal.convolve2d(im, psf, mode = <span class="hljs-string">&#x27;same&#x27;</span>)<br>im1 += <span class="hljs-number">0.1</span>*np.std(im1)*np.random.standard_normal(im.shape)<br><br></code></pre></td></tr></table></figure><p>再使用维纳滤波完成操作，最后就能得到图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>im2, _ = restoration.unsupervised_wiener(im1, psf)<br>fig, axes = pylab.subplots(nrows = <span class="hljs-number">1</span>, ncols = <span class="hljs-number">3</span>, figsize = (<span class="hljs-number">200</span>, <span class="hljs-number">40</span>), sharex = <span class="hljs-literal">True</span>,<br> sharey = <span class="hljs-literal">True</span>)<br>pylab.gray()<br>axes[<span class="hljs-number">0</span>].imshow(im), axes[<span class="hljs-number">0</span>].axis(<span class="hljs-string">&#x27;off&#x27;</span>), axes[<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&#x27;Original image&#x27;</span>, size = <span class="hljs-number">200</span>)<br>axes[<span class="hljs-number">1</span>].imshow(im1), axes[<span class="hljs-number">1</span>].axis(<span class="hljs-string">&#x27;off&#x27;</span>), axes[<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;Noisy blurred image&#x27;</span>, size = <span class="hljs-number">200</span>)<br>axes[<span class="hljs-number">2</span>].imshow(im2), axes[<span class="hljs-number">2</span>].axis(<span class="hljs-string">&#x27;off&#x27;</span>), axes[<span class="hljs-number">2</span>].set_title(<span class="hljs-string">&#x27;Self tuned restoration&#x27;</span>, size = <span class="hljs-number">200</span>)<br>fig.tight_layout()<br>pylab.show()<br><br></code></pre></td></tr></table></figure><h2 id="使用低通滤波重建图像">使用低通滤波，重建图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>im_fft = fp.ifftshift(im_fft_shift)<br>im = np.clip(fp.ifft2(im_fft).real, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<br>pylab.figure(figsize = (<span class="hljs-number">10</span>,<span class="hljs-number">10</span>))<br>pylab.imshow(im,pylab.cm.gray), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>), pylab.title(<span class="hljs-string">&#x27;Noise image&#x27;</span>), pylab.show()<br><br>keep_fraction = <span class="hljs-number">0.1</span><br>r,c = im_fft.shape<br>im_fft[<span class="hljs-built_in">int</span>(r*keep_fraction):<span class="hljs-built_in">int</span>(r*(<span class="hljs-number">1</span>-keep_fraction))] = <span class="hljs-number">0</span><br>im_fft[:, <span class="hljs-built_in">int</span>(c*keep_fraction):<span class="hljs-built_in">int</span>(c*(<span class="hljs-number">1</span>-keep_fraction))] = <span class="hljs-number">0</span><br>pylab.figure(), plot_spectrum(fp.fftshift(im_fft)), pylab.title(<span class="hljs-string">&#x27;Filitered Spectrum&#x27;</span>)<br><br>im_new = fp.ifft2(im_fft).real<br>pylab.figure(figsize = (<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br>pylab.imshow(im_new,pylab.cm.gray), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>), pylab.title(<span class="hljs-string">&#x27;Reconstructed image&#x27;</span>), pylab.show()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高斯差分和超高斯滤波</title>
    <link href="/2022/07/05/gauss_diff/"/>
    <url>/2022/07/05/gauss_diff/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gauss_func</span>(<span class="hljs-params">Nx, sigma, n</span>):<br>    x = np.arange(Nx) * dx<br>    cen = x0<br>    <span class="hljs-built_in">print</span>(cen)<br>    amp = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> amp * np.exp(-(x - cen) ** n / (<span class="hljs-number">2</span> * sigma ** n))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gauss_func2d</span>(<span class="hljs-params">Nx, Ny, sigma, n</span>):<br>    x = np.arange(Nx)<br>    y = np.arange(Ny)<br>    Y, X = np.meshgrid(y, x)<br>    cen = [x0, y0]<br>    <span class="hljs-built_in">print</span>(cen)<br>    amp = <span class="hljs-number">1</span><br>    R = np.sqrt((X * dx - cen[<span class="hljs-number">0</span>])**<span class="hljs-number">2</span> + (Y * dy - cen[<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> amp * np.exp(- R ** n / (<span class="hljs-number">2</span> * sigma ** n))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>超高斯滤波和阶跃函数</title>
    <link href="/2022/07/05/guass/"/>
    <url>/2022/07/05/guass/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>matplotlib colorbar位置</title>
    <link href="/2022/07/04/matplotlib/"/>
    <url>/2022/07/04/matplotlib/</url>
    
    <content type="html"><![CDATA[<p>matplotlib 3.5以上版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>fig, ax = plt.subplots(figsize = [<span class="hljs-number">3</span>, <span class="hljs-number">1.5</span>])<br>norm = mpl.colors.Normalize(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, clip=<span class="hljs-literal">True</span>)<br>im = plt.pcolormesh([[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>]], cmap = <span class="hljs-string">&#x27;jet&#x27;</span>, norm = norm)<br><br>cbar2 = fig.colorbar(im, cmap = <span class="hljs-string">&#x27;jet&#x27;</span>, location=<span class="hljs-string">&#x27;top&#x27;</span>,  shrink = <span class="hljs-number">0.8</span>)<br>cbar2.set_label(<span class="hljs-string">&#x27;E$_k$ [MeV]&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>如果figure.colorbar没有location参数，则使用mpl.colorbar.make_axes或者mpl.colorbar.make_axes_gridspec构造cax然后生成调用Colorbar构造函数生成cbar</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#plt.colorbar().set_label.__doc__</span><br><span class="hljs-comment">#kw = &#123;&quot;location&quot;: &quot;top&quot;, &quot;orientation&quot;: &quot;horizontal&quot;,</span><br><span class="hljs-comment">#                   &quot;anchor&quot;: (0.5, 0.0), &quot;panchor&quot;: (0.5, 1.0), &quot;pad&quot;: 0.05&#125;</span><br><span class="hljs-comment">#kw[&#x27;orientation&#x27;] = kw[&#x27;orientation&#x27;]</span><br><span class="hljs-comment">#location = kw[&#x27;ticklocation&#x27;] = kw[&#x27;location&#x27;]</span><br><br>kw = &#123;<span class="hljs-string">&#x27;shrink&#x27;</span>: <span class="hljs-number">0.8</span>, <span class="hljs-string">&#x27;orientation&#x27;</span>: <span class="hljs-string">&quot;horizontal&quot;</span>, <span class="hljs-string">&#x27;location&#x27;</span>: <span class="hljs-string">&#x27;top&#x27;</span>&#125;<br><span class="hljs-comment">#cax, kw = mpl.colorbar.make_axes_gridspec(ax, **kw)</span><br>cax, kw = mpl.colorbar.make_axes(ax, **kw)<br><br>NON_COLORBAR_KEYS = [<span class="hljs-string">&#x27;fraction&#x27;</span>, <span class="hljs-string">&#x27;pad&#x27;</span>, <span class="hljs-string">&#x27;shrink&#x27;</span>, <span class="hljs-string">&#x27;aspect&#x27;</span>, <span class="hljs-string">&#x27;anchor&#x27;</span>,<br>                        <span class="hljs-string">&#x27;panchor&#x27;</span>]<br><br>cb_kw = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kw.items() <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> NON_COLORBAR_KEYS&#125;<br><br>cbar = mpl.colorbar.Colorbar(cax, im, ticklocation = <span class="hljs-string">&quot;top&quot;</span>, orientation = <span class="hljs-string">&quot;horizontal&quot;</span>)<br>cbar.set_label(<span class="hljs-string">&#x27;E$_k$ [MeV]&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>此外，也可以自定义cax然后生成cbar</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>cax = fig.add_axes([<span class="hljs-number">0.15</span>, <span class="hljs-number">1.05</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.05</span>], label=<span class="hljs-string">&quot;&lt;colorbar&gt;&quot;</span>)<br>cbar = mpl.colorbar.Colorbar(cax, im, orientation = <span class="hljs-string">&quot;horizontal&quot;</span>, ticklocation = <span class="hljs-string">&quot;top&quot;</span>)<br>cbar.set_ticks([<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>])<br>cbar.ax.xaxis.set_ticks_position(<span class="hljs-string">&#x27;top&#x27;</span>)<br>cbar.ax.xaxis.set_label_position(<span class="hljs-string">&#x27;top&#x27;</span>)<br>cbar.set_label(<span class="hljs-string">&#x27;E$_k$ [MeV]&#x27;</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>卷积算法实现AutoCorr和高斯滤波（高斯模糊）</title>
    <link href="/2022/07/03/conv/"/>
    <url>/2022/07/03/conv/</url>
    
    <content type="html"><![CDATA[<h2 id="自相关">自相关</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br>rng = np.random.default_rng()<br>sig = rng.standard_normal(<span class="hljs-number">1000</span>)<br>autocorr = signal.fftconvolve(sig, sig[::-<span class="hljs-number">1</span>], mode=<span class="hljs-string">&#x27;full&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="高斯滤波">高斯滤波</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scipy<br><span class="hljs-keyword">from</span> scipy.ndimage <span class="hljs-keyword">import</span> gaussian_filter<br><span class="hljs-keyword">import</span> scipy.signal <span class="hljs-keyword">as</span> signal<br><br>c = <span class="hljs-number">3e8</span><br>dx = <span class="hljs-number">1e-6</span> * (x[<span class="hljs-number">1</span>] - x[<span class="hljs-number">0</span>])<br>sigma = c/<span class="hljs-number">10e12</span>/dx<br><br>EyTHz = scipy.ndimage.gaussian_filter(EyEnd, sigma = <span class="hljs-number">15</span>)<br><br></code></pre></td></tr></table></figure><p>使用高斯核卷积进行滤波</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>im = EyEnd<br>gauss_kernel = np.outer(signal.gaussian(im.shape[<span class="hljs-number">0</span>], <span class="hljs-number">15</span>), signal.gaussian(im.shape[<span class="hljs-number">1</span>], <span class="hljs-number">15</span>))<br><span class="hljs-comment">#gauss_kernel = gauss_kernel/np.sum(gauss_kernel)</span><br>gauss_kernel /= np.trapz(np.trapz(gauss_kernel))<br>im_real = signal.convolve(im, gauss_kernel, mode=<span class="hljs-string">&#x27;same&#x27;</span>)<br><span class="hljs-comment">#im_real = im * gauss_kernel</span><br><br></code></pre></td></tr></table></figure><p>其中sigma为滤波宽度</p><h2 id="使用卷积实现滤波">使用卷积实现滤波</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-comment">#from scipy import misc</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment">####动态模糊核心</span><br>guass_kernal = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>                [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>                [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]<br><br>result = signal.convolve2d(origin, guass_kernal, boundary=<span class="hljs-string">&#x27;symm&#x27;</span>, mode=<span class="hljs-string">&#x27;same&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>二维的卷积运算还有一种函数，是signal.sepfir2d()，它可以传入三个参数，后两个参数指定行和列的卷积和(两个方向上的卷积是可以不同的，分别指定卷积和序列)。</p><h2 id="频域卷积">频域卷积</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> numpy.fft <span class="hljs-keyword">as</span> fp<br><br>im = EyEnd <span class="hljs-comment">#EyEnd为需要滤波的图像</span><br><br>gauss_kernel = np.outer(signal.gaussian(im.shape[<span class="hljs-number">0</span>], <span class="hljs-number">15</span>), <br>signal.gaussian(im.shape[<span class="hljs-number">1</span>], <span class="hljs-number">15</span>))<br><br>plt.pcolormesh(gauss_kernel, cmap = <span class="hljs-string">&#x27;jet&#x27;</span>)<br><br>freq = np.fft.fft2(im)<br><span class="hljs-keyword">assert</span>(freq.shape == gauss_kernel.shape)<br>freq_kernel = np.fft.fft2(np.fft.ifftshift(gauss_kernel))<br><br>fig = plt.figure(figsize = (<span class="hljs-number">10</span>, <span class="hljs-number">4</span>))<br>ax_1 = fig.add_subplot(<span class="hljs-number">121</span>, projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br>ax_2 = fig.add_subplot(<span class="hljs-number">122</span>, projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br> <br>Y = np.arange(<span class="hljs-number">0</span> - <span class="hljs-built_in">int</span>(im.shape[<span class="hljs-number">0</span>]/<span class="hljs-number">2</span>), im.shape[<span class="hljs-number">0</span>] - <span class="hljs-built_in">int</span>(im.shape[<span class="hljs-number">0</span>]/<span class="hljs-number">2</span>), <span class="hljs-number">1</span>)<br>X = np.arange(<span class="hljs-number">0</span> - <span class="hljs-built_in">int</span>(im.shape[<span class="hljs-number">1</span>]/<span class="hljs-number">2</span>), im.shape[<span class="hljs-number">1</span>] - <span class="hljs-built_in">int</span>(im.shape[<span class="hljs-number">1</span>]/<span class="hljs-number">2</span>), <span class="hljs-number">1</span>)<br>X, Y = np.meshgrid(X, Y)<br> <br>ax_1.plot_surface(X, Y, np.log10(np.<span class="hljs-built_in">abs</span>(fp.ifftshift(freq))), rstride=<span class="hljs-number">4</span>,<br>cstride=<span class="hljs-number">4</span>, cmap=plt.cm.coolwarm)<br> <br>ax_2.plot_surface(X, Y, np.<span class="hljs-built_in">abs</span>(fp.ifftshift(freq_kernel)), rstride=<span class="hljs-number">4</span>,<br>cstride=<span class="hljs-number">4</span>, cmap=plt.cm.coolwarm)<br>plt.show()<br><br>conv = freq*freq_kernel<br>im1 = fp.ifft2(conv).real<br><br></code></pre></td></tr></table></figure><p>简洁版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> numpy.fft <span class="hljs-keyword">as</span> fp<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fftConv</span>(<span class="hljs-params">im, sigma</span>):<br><br>    gauss_kernel = np.outer(signal.gaussian(im.shape[<span class="hljs-number">0</span>], sigma), <br>    signal.gaussian(im.shape[<span class="hljs-number">1</span>], sigma))<br>    plotFreq(freqX, freqY, gauss_kernel.T)<br><br>    freq = np.fft.fft2(im)<br>    <span class="hljs-keyword">assert</span>(freq.shape == gauss_kernel.shape)<br>    freq_kernel = np.fft.fft2(np.fft.ifftshift(gauss_kernel))<br>    <span class="hljs-comment">#freq_kernel = np.fft.fft2(gauss_kernel)</span><br>    plotField(freqX, freqY, np.log10(np.<span class="hljs-built_in">abs</span>(fp.ifftshift(freq))).T)<br>    plotFreq(freqX, freqY, np.<span class="hljs-built_in">abs</span>(fp.ifftshift(freq_kernel)).T) <br><br>    conv = freq*freq_kernel<br>    im1 = fp.ifft2(conv).real<br>    <span class="hljs-keyword">return</span> im1<br><br>im = EyEnd<br>plotField(x, y, im.T)<br>sigma = <span class="hljs-number">15</span><br>im1 = fftConv(im, sigma)<br>plotField(freqX, freqY, im1.T) <br><br></code></pre></td></tr></table></figure><p>时域和频域对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pylab<br><br>freq = np.fft.fft2(im)<br><span class="hljs-keyword">assert</span>(freq.shape == gauss_kernel.shape)<br>freq_kernel = np.fft.fft2(np.fft.ifftshift(gauss_kernel))<br>conv = freq * freq_kernel<br>im1 = fp.ifft2(conv).real<br><br>pylab.figure(figsize = (<span class="hljs-number">20</span>, <span class="hljs-number">8</span>))<br>pylab.gray()<br>pylab.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>), pylab.pcolormesh(im.T, cmap = <span class="hljs-string">&#x27;bwr&#x27;</span>), pylab.title(<span class="hljs-string">&#x27;Original Image&#x27;</span>, size = <span class="hljs-number">30</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>pylab.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>), pylab.pcolormesh(gauss_kernel.T, cmap = <span class="hljs-string">&#x27;jet&#x27;</span>), pylab.title(<span class="hljs-string">&#x27;Gaussian Kernel&#x27;</span>, size = <span class="hljs-number">30</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>pylab.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>), pylab.pcolormesh(im1.T, cmap = <span class="hljs-string">&#x27;bwr&#x27;</span>), pylab.title(<span class="hljs-string">&#x27;Output Image&#x27;</span>, size = <span class="hljs-number">30</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br>imOrigin = (<span class="hljs-number">20</span>*np.log10(np.<span class="hljs-built_in">abs</span>(<span class="hljs-number">0.1</span>+fp.ifftshift(freq)))).astype(<span class="hljs-built_in">int</span>)<br>pylab.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), pylab.pcolormesh(imOrigin.T, cmap = <span class="hljs-string">&#x27;bwr&#x27;</span>)<br>pylab.title(<span class="hljs-string">&#x27;Origin Image Spectrum&#x27;</span>, size = <span class="hljs-number">30</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br>imGuassian = (<span class="hljs-number">20</span>*np.log10(np.<span class="hljs-built_in">abs</span>(<span class="hljs-number">0.1</span>+fp.ifftshift(freq_kernel)))).astype(<span class="hljs-built_in">int</span>)<br>pylab.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>), pylab.pcolormesh(imGuassian.T, cmap = <span class="hljs-string">&#x27;jet&#x27;</span>)<br>pylab.title(<span class="hljs-string">&#x27;Gaussian Kernel Spectrum&#x27;</span>, size = <span class="hljs-number">30</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br>imOutSpec = (<span class="hljs-number">20</span>*np.log10(np.<span class="hljs-built_in">abs</span>(<span class="hljs-number">0.1</span>+fp.ifftshift(conv)))).astype(<span class="hljs-built_in">int</span>)<br>pylab.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>), pylab.pcolormesh(imOutSpec.T, cmap = <span class="hljs-string">&#x27;jet&#x27;</span>)<br>pylab.title(<span class="hljs-string">&#x27;Output Image Spectrum&#x27;</span>, size = <span class="hljs-number">30</span>), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="带通滤波">带通滤波</h2><p>在这里尝试使用高斯差分核（两个高斯核的差），作为带通滤波器。带通滤波是保留一定频段内的频率分量，而丢弃其余所有的频率分量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">###读取图像</span><br>im = img_as_float(pylab.imread(<span class="hljs-string">&#x27;./images/snow.jpg&#x27;</span>))<br>pylab.figure(), pylab.imshow(im), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>), pylab.show()<br>x = np.linspace(-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>)<br><span class="hljs-comment">###kernel 1 生成</span><br>kernel = np.exp(-<span class="hljs-number">0.005</span>*x**<span class="hljs-number">2</span>)<br>kernel /= np.trapz(kernel)<br>guass_kernel_1 = kernel[:, np.newaxis] * kernel[np.newaxis, :]<br><span class="hljs-comment">###kernel 2 生成</span><br>kernel = np.exp(-<span class="hljs-number">5</span>*x**<span class="hljs-number">2</span>)<br>kernel /= np.trapz(kernel)<br>guass_kernel_2 = kernel[:, np.newaxis] * kernel[np.newaxis, :]<br><span class="hljs-comment">###进行差分</span><br>DOGkernel = guass_kernel_1[:,:,np.newaxis] - guass_kernel_2[:,:,np.newaxis]<br><span class="hljs-comment">###卷积</span><br>im = signal.fftconvolve(im, DOGkernel, mode = <span class="hljs-string">&#x27;same&#x27;</span>)<br>pylab.figure, pylab.imshow(np.clip(im, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)), pylab.axis(<span class="hljs-string">&#x27;off&#x27;</span>), <span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">max</span>(im))<br>pylab.show()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>卷积算法实现AutoCorr和高斯滤波（高斯模糊）</title>
    <link href="/2022/07/03/myfftconvolve/"/>
    <url>/2022/07/03/myfftconvolve/</url>
    
    <content type="html"><![CDATA[<h2 id="自定义fft卷积">自定义FFT卷积</h2><p>使用fftshift(fft(fftshift(signal))):</p><p>1.不改变频谱的幅度和相位</p><p>2.使得频谱的范围为-Fs/2到Fs/2，中心频率为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fftconvolve</span>(<span class="hljs-params">im, gauss_kernel</span>):<br>    gauss_f = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(gauss_kernel)))<br>    <span class="hljs-comment">#plotFreq(x, y, np.log(np.abs(gauss_f)).T)</span><br>    <span class="hljs-comment">#plotFreq(x, y, np.log(np.angle(gauss_f)).T)</span><br>    im_r = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(im)))<br>    <span class="hljs-comment">#plotField(x, y, np.log(np.abs(im_r)).T)</span><br>    <span class="hljs-comment">#plotFreq(x, y, np.log(np.angle(im_r)).T)</span><br>    im_filter = np.fft.ifftshift(np.fft.ifft2(np.fft.ifftshift(gauss_f * im_r))).real<br>    <span class="hljs-comment">#plotField(x, y, im_filter.T)</span><br>    <span class="hljs-keyword">return</span> im_filter<br><br>im_filter = fftconvolve(im, gauss_kernel)<br><br></code></pre></td></tr></table></figure><p>只改变gauss_kernal的fft也可以得到相同的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fftconvolve</span>(<span class="hljs-params">im, gauss_kernel</span>):<br>    gauss_f = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(gauss_kernel)))<br>    <span class="hljs-comment">#plotFreq(x, y, np.log(np.abs(gauss_f)).T)</span><br>    <span class="hljs-comment">#plotFreq(x, y, np.log(np.angle(gauss_f)).T)</span><br>    im_r = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(im)))<br>    <span class="hljs-comment">#plotField(x, y, np.log(np.abs(im_r)).T)</span><br>    <span class="hljs-comment">#plotFreq(x, y, np.log(np.angle(im_r)).T)</span><br>    im_filter = np.fft.ifftshift(np.fft.ifft2(np.fft.ifftshift(gauss_f * im_r))).real<br>    <span class="hljs-comment">#plotField(x, y, im_filter.T)</span><br>    <span class="hljs-keyword">return</span> im_filter<br><br>im_filter = fftconvolve(im, gauss_kernel)<br><br></code></pre></td></tr></table></figure><p>使用fftshift和不适用fftshift的相位角对比。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分治算法</title>
    <link href="/2022/07/01/Divide-and-Conquer/"/>
    <url>/2022/07/01/Divide-and-Conquer/</url>
    
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>给你一个由数字和运算符组成的字符串 expression，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以按任意顺序 返回答案。</p><p>生成的测试用例满足其对应输出值符合 32位整数范围，不同结果的数量不超过 <spanclass="math inline">\(10^4\)</span> 。</p><h3 id="示例">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">输入：expression = <span class="hljs-string">&quot;2-1-1&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br>解释：<br>((<span class="hljs-number">2</span><span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>) = <span class="hljs-number">0</span> <br>(<span class="hljs-number">2</span>-(<span class="hljs-number">1</span><span class="hljs-number">-1</span>)) = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="解题思路">解题思路</h2><p>对于一个形如 x op y（op 为运算符，x 和 y 为数）的算式而言，它的结果组合取决于 x 和 y 的结果组合数，而 x 和 y又可以写成形如 x op y 的算式。</p><p>因此，该问题的子问题就是 x op y 中的 x 和y：以运算符分隔的左右两侧算式解。</p><p>然后我们来进行 分治算法三步走：</p><p>分解：按运算符分成左右两部分，分别求解解决：实现一个递归函数，输入算式，返回算式解合并：根据运算符合并左右两部分的解，得出最终解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string expression)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec1, vec2, res;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = expression.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">char</span> oper = expression[i];<br>            <span class="hljs-keyword">if</span>(oper == <span class="hljs-string">&#x27;+&#x27;</span> || oper == <span class="hljs-string">&#x27;-&#x27;</span> || oper == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                flag = <span class="hljs-number">1</span>;<br>                vec1 = <span class="hljs-built_in">diffWaysToCompute</span>(<span class="hljs-built_in">string</span>(expression, <span class="hljs-number">0</span>, i));<br>                vec2 = <span class="hljs-built_in">diffWaysToCompute</span>(<span class="hljs-built_in">string</span>(expression, i + <span class="hljs-number">1</span>, n - i - <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v1: vec1)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v2: vec2)&#123;<br>                        <span class="hljs-keyword">if</span>(oper == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>                            res.<span class="hljs-built_in">push_back</span>(v1 + v2);<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                            res.<span class="hljs-built_in">push_back</span>(v1 - v2);<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            res.<span class="hljs-built_in">push_back</span>(v1 * v2);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;std::<span class="hljs-built_in">stoi</span>(expression)&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>以及<strong>python</strong>版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diffWaysToCompute</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span>: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 如果只有数字，直接返回</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">input</span>.isdigit():<br>            <span class="hljs-keyword">return</span> [<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>)]<br><br>        res = []<br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">input</span>):<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>]:<br>                <span class="hljs-comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span><br>                <span class="hljs-comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span><br>                left = <span class="hljs-variable language_">self</span>.diffWaysToCompute(<span class="hljs-built_in">input</span>[:i])<br>                right = <span class="hljs-variable language_">self</span>.diffWaysToCompute(<span class="hljs-built_in">input</span>[i+<span class="hljs-number">1</span>:])<br>                <span class="hljs-comment"># 3.合并：根据运算符合并子问题的解</span><br>                <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> left:<br>                    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> right:<br>                        <span class="hljs-keyword">if</span> char == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                            res.append(l + r)<br>                        <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                            res.append(l - r)<br>                        <span class="hljs-keyword">else</span>:<br>                            res.append(l * r)<br><br>        <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PRL投稿问题</title>
    <link href="/2022/07/01/REVTex/"/>
    <url>/2022/07/01/REVTex/</url>
    
    <content type="html"><![CDATA[<h2 id="prl投稿问题">PRL投稿问题</h2><p>PRL投稿需要使用REVTEX，而使用REVTEX模板发现去除所有内容后，abstract后自动换页然后输出。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>EPOCH Code For Spectrum</title>
    <link href="/2022/06/30/centspec/"/>
    <url>/2022/06/30/centspec/</url>
    
    <content type="html"><![CDATA[<p>Use EPOCH Code to get axis spectrum</p><h2 id="sdf_write">SDF_Write</h2><p>Use this syntex can save axis Ey to file:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Fortran"><span class="hljs-keyword">CALL</span> sdf_write_plain_variable(sdf_handle, id, <span class="hljs-keyword">name</span>, <br>units, dims, stagger, &amp; grid_id, variable,<br>subtype_field, subarray_field)  <br></code></pre></td></tr></table></figure><p>The parameters have the following types and meanings:</p><p><span class="math inline">\(\cdot\)</span> block id - The id name ofthe variable. This character string is a unique identifier for thevariable in the file enabling a program to retrieve it later. Oncedefined it should not change so that newer versions of EPOCH can stillidentify variables generated by older versions.</p><p><span class="math inline">\(\cdot\)</span> name - The display name ofthe variable. This character string is the name that is used by externalprograms to display an identifying name for the variable. If it contains’/’ characters then these are used by VisIt to group the variables.</p><p><span class="math inline">\(\cdot\)</span> units - The units of thevariable. This character string is used when displaying the data units.For most variables in EPOCH these are SI units.</p><p><span class="math inline">\(\cdot\)</span> dims - An nD integer arraycontaining the GLOBAL length of the variable across all processors. InEPOCH a variable actually called “dims” exists for variables which arethe same size as the default field variables.</p><p><span class="math inline">\(\cdot\)</span> stagger - An integerconstant containing the stagger of a variable from the cell centre of acell. This property lets external programs know the position of avariable on the grid.</p><p><span class="math inline">\(\cdot\)</span> grid id - The id name ofthe grid to which the variable is attached. In EPOCH , the main grid isjust called “grid”. Note that this property is case sensitive.</p><p><span class="math inline">\(\cdot\)</span> variable - The actualvariable to be written to disk.</p><p><span class="math inline">\(\cdot\)</span> subtype field - This is anMPI type representing the layout of the data across the processors. Fora standard field variable, there is an automatically created type called“subtype field” which should be used here.</p><p><span class="math inline">\(\cdot\)</span> subarray field - This isan MPI type representing the section of the “variable” parameter to bewritten. For a standard field variable, there is an automaticallycreated type called “subarray field” which should be used here.</p><h2 id="example">Example</h2><p>For Example, derived variables <strong>array</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Fortran"><span class="hljs-keyword">IF</span> (<span class="hljs-built_in">IAND</span>(dumpmask(c_dump_myvar), code)) <span class="hljs-keyword">THEN</span><br>  <span class="hljs-keyword">CALL</span> calc_my_variable(array)<br>  <span class="hljs-keyword">CALL</span> sdf_write_plain_variable(sdf_handle, ’my_var’,<br>  ’Mine/variable’, ’<span class="hljs-keyword">unit</span>’, dims, c_stagger_cell_centre, <br>  ’grid’, array, subtype_field, subarray_field)<br><span class="hljs-keyword">ENDIF</span><br></code></pre></td></tr></table></figure><h2 id="cent-spec">Cent Spec</h2><p>extract the central ey and save to sdf by subroutine<strong>sdf_write_plain_variable(...)</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>When to Use Static Generation v.s. Server-side Rendering</title>
    <link href="/2020/01/02/ssg-ssr/"/>
    <url>/2020/01/02/ssg-ssr/</url>
    
    <content type="html"><![CDATA[<p>We recommend using <strong>Static Generation</strong> (with andwithout data) whenever possible because your page can be built once andserved by CDN, which makes it much faster than having a server renderthe page on every request.</p><p>You can use Static Generation for many types of pages, including:</p><ul><li>Marketing pages</li><li>Blog posts</li><li>E-commerce product listings</li><li>Help and documentation</li></ul><p>You should ask yourself: "Can I pre-render this page<strong>ahead</strong> of a user's request?" If the answer is yes, thenyou should choose Static Generation.</p><p>On the other hand, Static Generation is <strong>not</strong> a goodidea if you cannot pre-render a page ahead of a user's request. Maybeyour page shows frequently updated data, and the page content changes onevery request.</p><p>In that case, you can use <strong>Server-Side Rendering</strong>. Itwill be slower, but the pre-rendered page will always be up-to-date. Oryou can skip pre-rendering and use client-side JavaScript to populatedata.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Two Forms of Pre-rendering</title>
    <link href="/2020/01/01/pre-rendering/"/>
    <url>/2020/01/01/pre-rendering/</url>
    
    <content type="html"><![CDATA[<p>Next.js has two forms of pre-rendering: <strong>StaticGeneration</strong> and <strong>Server-side Rendering</strong>. Thedifference is in <strong>when</strong> it generates the HTML for apage.</p><ul><li><strong>Static Generation</strong> is the pre-rendering method thatgenerates the HTML at <strong>build time</strong>. The pre-rendered HTMLis then <em>reused</em> on each request.</li><li><strong>Server-side Rendering</strong> is the pre-rendering methodthat generates the HTML on <strong>each request</strong>.</li></ul><p>Importantly, Next.js lets you <strong>choose</strong> whichpre-rendering form to use for each page. You can create a "hybrid"Next.js app by using Static Generation for most pages and usingServer-side Rendering for others.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
